/**
 *
 * Copyright (c) 2014, the Railo Company Ltd. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see <http:></http:>//www.gnu.org/licenses/>.
 *
 */
package lucee.runtime.db.driver

import java.lang.reflect.InvocationTargetException

class StatementProxy(conn: ConnectionProxy, stat: Statement) : StatementPro {
    protected var conn: ConnectionProxy
    protected var stat: Statement

    @Override
    @Throws(SQLException::class)
    override fun execute(pc: PageContext?, sql: String?): Boolean {
        return stat.execute(sql)
    }

    @Override
    @Throws(SQLException::class)
    override fun execute(pc: PageContext?, sql: String?, autoGeneratedKeys: Int): Boolean {
        return stat.execute(sql, autoGeneratedKeys)
    }

    @Override
    @Throws(SQLException::class)
    override fun execute(pc: PageContext?, sql: String?, columnIndexes: IntArray?): Boolean {
        return stat.execute(sql, columnIndexes)
    }

    @Override
    @Throws(SQLException::class)
    override fun execute(pc: PageContext?, sql: String?, columnNames: Array<String?>?): Boolean {
        return stat.execute(sql, columnNames)
    }

    @Override
    @Throws(SQLException::class)
    override fun executeQuery(pc: PageContext?, sql: String?): ResultSet {
        return stat.executeQuery(sql)
    }

    @Override
    @Throws(SQLException::class)
    override fun executeUpdate(pc: PageContext?, sql: String?): Int {
        return stat.executeUpdate(sql)
    }

    @Override
    @Throws(SQLException::class)
    override fun executeUpdate(pc: PageContext?, sql: String?, autoGeneratedKeys: Int): Int {
        return stat.executeUpdate(sql, autoGeneratedKeys)
    }

    @Override
    @Throws(SQLException::class)
    override fun executeUpdate(pc: PageContext?, sql: String?, columnIndexes: IntArray?): Int {
        return stat.executeUpdate(sql, columnIndexes)
    }

    @Override
    @Throws(SQLException::class)
    override fun executeUpdate(pc: PageContext?, sql: String?, columnNames: Array<String?>?): Int {
        return stat.executeUpdate(sql, columnNames)
    }

    @Override
    @Throws(SQLException::class)
    fun execute(sql: String?): Boolean {
        return stat.execute(sql)
    }

    @Override
    @Throws(SQLException::class)
    fun execute(sql: String?, autoGeneratedKeys: Int): Boolean {
        return stat.execute(sql, autoGeneratedKeys)
    }

    @Override
    @Throws(SQLException::class)
    fun execute(sql: String?, columnIndexes: IntArray?): Boolean {
        return stat.execute(sql, columnIndexes)
    }

    @Override
    @Throws(SQLException::class)
    fun execute(sql: String?, columnNames: Array<String?>?): Boolean {
        return stat.execute(sql, columnNames)
    }

    @Override
    @Throws(SQLException::class)
    fun executeBatch(): IntArray {
        return stat.executeBatch()
    }

    @Override
    @Throws(SQLException::class)
    fun executeQuery(sql: String?): ResultSet {
        return stat.executeQuery(sql)
    }

    @Override
    @Throws(SQLException::class)
    fun executeUpdate(sql: String?): Int {
        return stat.executeUpdate(sql)
    }

    @Override
    @Throws(SQLException::class)
    fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int {
        return stat.executeUpdate(sql, autoGeneratedKeys)
    }

    @Override
    @Throws(SQLException::class)
    fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int {
        return stat.executeUpdate(sql, columnIndexes)
    }

    @Override
    @Throws(SQLException::class)
    fun executeUpdate(sql: String?, columnNames: Array<String?>?): Int {
        return stat.executeUpdate(sql, columnNames)
    }

    @get:Throws(SQLException::class)
    @get:Override
    val connection: Connection
        get() = conn

    @get:Throws(SQLException::class)
    @get:Override
    val generatedKeys: ResultSet
        get() = stat.getGeneratedKeys()

    @get:Throws(SQLException::class)
    @get:Override
    val resultSet: ResultSet
        get() = stat.getResultSet()

    @Override
    @Throws(SQLException::class)
    fun isWrapperFor(iface: Class<*>?): Boolean {
        return stat.isWrapperFor(iface)
    }

    @Override
    @Throws(SQLException::class)
    fun <T> unwrap(iface: Class<T>?): T {
        return stat.unwrap(iface)
    }

    @Override
    @Throws(SQLException::class)
    fun addBatch(sql: String?) {
        stat.addBatch(sql)
    }

    @Override
    @Throws(SQLException::class)
    fun cancel() {
        stat.cancel()
    }

    @Override
    @Throws(SQLException::class)
    fun clearBatch() {
        stat.clearBatch()
    }

    @Override
    @Throws(SQLException::class)
    fun clearWarnings() {
        stat.clearWarnings()
    }

    @Override
    @Throws(SQLException::class)
    fun close() {
        stat.close()
    }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var fetchDirection: Int
        get() = stat.getFetchDirection()
        set(direction) {
            stat.setFetchDirection(direction)
        }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var fetchSize: Int
        get() = stat.getFetchSize()
        set(rows) {
            stat.setFetchSize(rows)
        }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var maxFieldSize: Int
        get() = stat.getMaxFieldSize()
        set(max) {
            stat.setMaxFieldSize(max)
        }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var maxRows: Int
        get() = stat.getMaxRows()
        set(max) {
            stat.setMaxRows(max)
        }

    @get:Throws(SQLException::class)
    @get:Override
    val moreResults: Boolean
        get() = stat.getMoreResults()

    @Override
    @Throws(SQLException::class)
    fun getMoreResults(current: Int): Boolean {
        return stat.getMoreResults(current)
    }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var queryTimeout: Int
        get() = stat.getQueryTimeout()
        set(seconds) {
            if (seconds > 0) stat.setQueryTimeout(seconds)
        }

    @get:Throws(SQLException::class)
    @get:Override
    val resultSetConcurrency: Int
        get() = stat.getResultSetConcurrency()

    @get:Throws(SQLException::class)
    @get:Override
    val resultSetHoldability: Int
        get() = stat.getResultSetHoldability()

    @get:Throws(SQLException::class)
    @get:Override
    val resultSetType: Int
        get() = stat.getResultSetType()

    @get:Throws(SQLException::class)
    @get:Override
    val updateCount: Int
        get() = stat.getUpdateCount()

    @get:Throws(SQLException::class)
    @get:Override
    val warnings: SQLWarning
        get() = stat.getWarnings()

    @get:Throws(SQLException::class)
    @get:Override
    val isClosed: Boolean
        get() = stat.isClosed()

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var isPoolable: Boolean
        get() = stat.isPoolable()
        set(poolable) {
            stat.setPoolable(poolable)
        }

    @Override
    @Throws(SQLException::class)
    fun setCursorName(name: String?) {
        stat.setCursorName(name)
    }

    @Override
    @Throws(SQLException::class)
    fun setEscapeProcessing(enable: Boolean) {
        stat.setEscapeProcessing(enable)
    }

    // used only with java 7, do not set @Override
    @Throws(SQLException::class)
    fun closeOnCompletion() {
        // used reflection to make sure this work with Java 5 and 6
        try {
            stat.getClass().getMethod("closeOnCompletion", arrayOfNulls<Class>(0)).invoke(stat, arrayOfNulls<Object>(0))
        } catch (t: Throwable) {
            ExceptionUtil.rethrowIfNecessary(t)
            if (t is InvocationTargetException && (t as InvocationTargetException).getTargetException() is SQLException) throw (t as InvocationTargetException).getTargetException() as SQLException
            throw PageRuntimeException(Caster.toPageException(t))
        }
    }// used reflection to make sure this work with Java 5 and 6

    // used only with java 7, do not set @Override
    @get:Throws(SQLException::class)
    val isCloseOnCompletion: Boolean
        get() =// used reflection to make sure this work with Java 5 and 6
            try {
                Caster.toBooleanValue(stat.getClass().getMethod("isCloseOnCompletion", arrayOfNulls<Class>(0)).invoke(stat, arrayOfNulls<Object>(0)))
            } catch (t: Throwable) {
                ExceptionUtil.rethrowIfNecessary(t)
                if (t is InvocationTargetException && (t as InvocationTargetException).getTargetException() is SQLException) throw (t as InvocationTargetException).getTargetException() as SQLException
                throw PageRuntimeException(Caster.toPageException(t))
            }

    init {
        this.conn = conn
        this.stat = stat
    }
}