/**
 * Copyright (c) 2014, the Railo Company Ltd.
 * Copyright (c) 2015, Tachyon Assosication Switzerland
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see <http:></http:>//www.gnu.org/licenses/>.
 *
 */
package tachyon.runtime.orm

import java.sql.Array

class ORMConnection(pc: PageContext?, session: ORMSession?, ds: DataSource?, transactionIsolation: Int) : Connection {
    private val session: ORMSession?

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var autoCommit = false
        set(autoCommit) {
            field = autoCommit
            if (autoCommit) {
                trans.end()
            }
        }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var transactionIsolation: Int
    private val trans: ORMTransaction?
    private val ds: DataSource?
    @Override
    @Throws(SQLException::class)
    fun clearWarnings() {
    }

    @Override
    @Throws(SQLException::class)
    fun close() {
    }

    @Override
    fun commit() {
        trans.commit()
    }

    @Override
    @Throws(SQLException::class)
    fun createStatement(): Statement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement? {
        throw notSupported()
    }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var catalog: String?
        get() {
            throw notSupported()
        }
        set(catalog) {}

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var holdability: Int
        get() {
            throw notSupported()
        }
        set(holdability) {}

    @get:Throws(SQLException::class)
    @get:Override
    val metaData: DatabaseMetaData?
        get() {
            throw notSupported()
        }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var typeMap: Map<String?, Any?>?
        get() {
            throw notSupported()
        }
        set(map) {
            throw notSupported()
        }

    @get:Throws(SQLException::class)
    @get:Override
    val warnings: SQLWarning?
        get() {
            throw notSupported()
        }

    @get:Throws(SQLException::class)
    @get:Override
    val isClosed: Boolean
        get() = !session.isValid(ds)

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var isReadOnly: Boolean
        get() = false
        set(readOnly) {}

    @Override
    @Throws(SQLException::class)
    fun nativeSQL(sql: String?): String? {
        return sql
    }

    @Override
    @Throws(SQLException::class)
    fun prepareCall(sql: String?): CallableStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int): CallableStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?): PreparedStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, columnIndexes: IntArray?): PreparedStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, columnNames: Array<String?>?): PreparedStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun releaseSavepoint(savepoint: Savepoint?) {
    }

    @Override
    fun rollback() {
        trans.rollback()
    }

    @Override
    @Throws(SQLException::class)
    fun rollback(savepoint: Savepoint?) {
        rollback()
    }

    @Override
    @Throws(SQLException::class)
    fun setSavepoint(): Savepoint? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun setSavepoint(name: String?): Savepoint? {
        throw notSupported()
    }

    /*
	 * private SQLException toSQLException(PageException pe) { SQLException e = new
	 * SQLException(pe.getMessage()); e.initCause(pe); return e; }
	 */
    @Override
    @Throws(SQLException::class)
    fun <T> unwrap(iface: Class<T?>?): T? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun isWrapperFor(iface: Class<*>?): Boolean {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun createClob(): Clob? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun createBlob(): Blob? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun isValid(timeout: Int): Boolean {
        throw notSupported()
    }

    @Override
    fun setClientInfo(name: String?, value: String?) {
        throw notSupportedEL()
    }

    @Override
    @Throws(SQLException::class)
    fun getClientInfo(name: String?): String? {
        throw notSupported()
    }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Override
    var clientInfo: Properties?
        get() {
            throw notSupported()
        }
        set(properties) {
            throw notSupportedEL()
        }

    @Override
    @Throws(SQLException::class)
    fun createArrayOf(typeName: String?, elements: Array<Object?>?): Array? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun createStruct(typeName: String?, attributes: Array<Object?>?): Struct? {
        throw notSupported()
    }

    private fun notSupported(): SQLException? {
        return SQLFeatureNotSupportedException("this feature is not supported")
    }

    private fun notSupportedEL(): RuntimeException? {
        return RuntimeException(SQLFeatureNotSupportedException("this feature is not supported"))
    }

    @Override
    @Throws(SQLException::class)
    fun createNClob(): NClob? {
        throw notSupported()
    }

    @Override
    @Throws(SQLException::class)
    fun createSQLXML(): SQLXML? {
        throw notSupported()
    }

    // used only with java 7, do not set @Override
    // used only with java 7, do not set @Override
    @get:Throws(SQLException::class)
    @set:Throws(SQLException::class)
    var schema: String?
        get() {
            throw notSupported()
        }
        set(schema) {
            throw notSupported()
        }

    // used only with java 7, do not set @Override
    @Throws(SQLException::class)
    fun abort(executor: Executor?) {
        throw notSupported()
    }

    // used only with java 7, do not set @Override
    @Throws(SQLException::class)
    fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        throw notSupported()
    }

    // used only with java 7, do not set @Override
    @get:Throws(SQLException::class)
    val networkTimeout: Int
        get() {
            throw notSupported()
        }
    // private boolean hasBegun;
    /**
     * Constructor of the class
     *
     * @param session
     * @param transactionIsolation
     * @throws PageException
     */
    init {
        this.session = session
        this.ds = ds
        this.transactionIsolation = transactionIsolation
        trans = session.getTransaction(ds.getName(), session.getEngine().getConfiguration(pc).autoManageSession())
        trans.begin()
    }
}