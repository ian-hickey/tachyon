/**
 * Copyright (c) 2014, the Railo Company Ltd.
 * Copyright (c) 2015, Tachyon Assosication Switzerland
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see <http:></http:>//www.gnu.org/licenses/>.
 *
 */
package tachyon.runtime.tag

import java.nio.charset.Charset

// TODO test proxy
/**
 *
 * Sends e-mail messages by an SMTP server.
 *
 *
 *
 */
class Mail : BodyTagImpl() {
    /**
     * Specifies the query column to use when you group sets of records together to send as an e-mail
     * message. For example, if you send a set of billing statements to customers, you might group on
     * "Customer_ID." The group attribute, which is case sensitive, eliminates adjacent duplicates when
     * the data is sorted by the specified field. See the Usage section for exceptions.
     */
    private var group: String? = null

    /**
     * Boolean indicating whether to group with regard to case or not. The default value is YES; case is
     * considered while grouping. If the query attribute specifies a query object that was generated by
     * a case-insensitive SQL query, set the groupCaseSensitive attribute to NO to keep the recordset
     * intact.
     */
    private var groupcasesensitive = false

    /**
     * The name of the cfquery from which to draw data for message(s) to send. Specify this attribute to
     * send more than one mail message, or to send the results of a query within a message.
     */
    private var query: String? = null

    /** Specifies the maximum number of e-mail messages to send.  */
    private var maxrows = 0.0

    /** Specifies the row in the query to start from.  */
    private var startrow = 0.0

    // private tachyon.runtime.mail.Mail mail=new tachyon.runtime.mail.Mail();
    private var smtp: SMTPClient? = SMTPClient()
    private var part: tachyon.runtime.net.mail.MailPart? = null // new tachyon.runtime.mail.MailPart("UTF-8");
    private var charset: CharSet? = null
    private var priority = 0
    private var remove = false

    /** specify the time for the message to be sent when using the spooler  */
    private var sendTime: DateTime? = null
    private var listener: Object? = null

    // private String regex = "^[\\w-_\\.+]*[\\w-_\\.]\\@([\\w]+\\.)+[\\w]+[\\w]$";
    @Override
    fun release() {
        super.release()
        // do not clear because spooler
        // mail=new tachyon.runtime.mail.Mail();
        smtp = SMTPClient()
        part = null // new tachyon.runtime.mail.MailPart("UTF-8");
        group = null
        groupcasesensitive = false
        query = null
        maxrows = 0.0
        startrow = 0.0
        charset = null
        remove = false
        sendTime = null
        listener = null
    }

    /**
     * @param remove the remove to set
     */
    fun setRemove(remove: Boolean) {
        this.remove = remove
    }

    /**
     * @param proxyserver The proxyserver to set.
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setProxyserver(proxyserver: String?) {
        try {
            smtp.getProxyData().setServer(proxyserver)
        } catch (e: Exception) {
            throw ApplicationException("Attribute [proxyserver] of the tag [mail] is invalid", e.getMessage())
        }
    }

    /**
     * set the value proxyport The port number on the proxy server from which the object is requested.
     * Default is 80. When used with resolveURL, the URLs of retrieved documents that specify a port
     * number are automatically resolved to preserve links in the retrieved document.
     *
     * @param proxyport value to set
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setProxyport(proxyport: Double) {
        try {
            smtp.getProxyData().setPort(proxyport.toInt())
        } catch (e: Exception) {
            throw ApplicationException("Attribute [proxyport] of the tag [mail] is invalid", e.getMessage())
        }
    }

    /**
     * set the value username When required by a proxy server, a valid username.
     *
     * @param proxyuser value to set
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setProxyuser(proxyuser: String?) {
        try {
            smtp.getProxyData().setUsername(proxyuser)
        } catch (e: Exception) {
            throw ApplicationException("Attribute [proxyuser] of the tag [mail] is invalid", e.getMessage())
        }
    }

    /**
     * set the value password When required by a proxy server, a valid password.
     *
     * @param proxypassword value to set
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setProxypassword(proxypassword: String?) {
        try {
            smtp.getProxyData().setPassword(proxypassword)
        } catch (e: Exception) {
            throw ApplicationException("Attribute [proxypassword] of the tag [mail] is invalid", e.getMessage())
        }
    }

    /**
     * set the value from The sender of the e-mail message.
     *
     * @param strForm value to set
     * @throws PageException
     */
    @Throws(PageException::class)
    fun setFrom(from: Object?) {
        val msg = "Attribute [from] of the tag [mail] cannot be empty"
        if (StringUtil.isEmpty(from, true)) throw ApplicationException(msg)
        try {
            smtp.setFrom(from)
        } catch (e: Exception) {
            val ae = ApplicationException("Attribute [from] of the tag [mail] is invalid", e.getMessage())
            ae.initCause(e)
            throw ae
        }
    }

    /**
     * set the value to The name of the e-mail message recipient.
     *
     * @param strTo value to set
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setTo(to: Object?) {
        if (StringUtil.isEmpty(to, true)) throw ApplicationException("Attribute [to] of the tag [mail] cannot be empty")
        try {
            smtp.addTo(to)
        } catch (e: Exception) {
            val ae = ApplicationException("Attribute [to] of the tag [mail] is invalid", e.getMessage())
            ae.initCause(e)
            throw ae
        }
    }

    /**
     * set the value cc Indicates addresses to copy the e-mail message to; "cc" stands for "carbon
     * copy."
     *
     * @param strCc value to set
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setCc(cc: Object?) {
        if (StringUtil.isEmpty(cc, true)) return
        try {
            smtp.addCC(cc)
        } catch (e: Exception) {
            val ae = ApplicationException("Attribute [cc] of the tag [mail] is invalid", e.getMessage())
            ae.initCause(e)
            throw ae
        }
    }

    /**
     * set the value bcc Indicates addresses to copy the e-mail message to, without listing them in the
     * message header. "bcc" stands for "blind carbon copy."
     *
     * @param strBcc value to set
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setBcc(bcc: Object?) {
        if (StringUtil.isEmpty(bcc, true)) return
        try {
            smtp.addBCC(bcc)
        } catch (e: Exception) {
            val ae = ApplicationException("Attribute [bcc] of the tag [mail] is invalid", e.getMessage())
            ae.initCause(e)
            throw ae
        }
    }

    /**
     * @param strFailto The failto to set.
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setFailto(failto: Object?) {
        if (StringUtil.isEmpty(failto, true)) return
        try {
            smtp.addFailTo(failto)
        } catch (e: Exception) {
            val ae = ApplicationException("Attribute [failto] of the tag [mail] is invalid", e.getMessage())
            ae.initCause(e)
            throw ae
        }
    }

    /**
     * @param strReplyto The replyto to set.
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setReplyto(replyto: Object?) {
        if (StringUtil.isEmpty(replyto, true)) return
        try {
            smtp.addReplyTo(replyto)
        } catch (e: Exception) {
            val ae = ApplicationException("Attribute [replyto] of the tag [mail] is invalid", e.getMessage())
            ae.initCause(e)
            throw ae
        }
    }

    /**
     * set the value type Specifies extended type attributes for the message.
     *
     * @param type value to set
     * @throws ApplicationException
     */
    @Throws(ApplicationException::class)
    fun setType(type: String?) {
        var type = type
        type = if (StringUtil.isEmpty(type, true)) "text/plain" else type.toLowerCase().trim()
        if (type.equals("text/plain") || type.equals("plain") || type.equals("text")) getPart()!!.isHTML(false) else if (type.equals("text/html") || type.equals("html") || type.equals("htm")) getPart()!!.isHTML(true) else throw ApplicationException("Attribute [type] of tag [mail]  has an invalid value [$type]",
                "Valid values are [plain, text, html] but value is now [$type]")
        // throw new ApplicationException(("invalid type "+type);
    }

    /**
     * set the value subject The subject of the mail message. This field may be driven dynamically on a
     * message-by-message basis
     *
     * @param subject value to set
     */
    fun setSubject(subject: String?) {
        smtp.setSubject(StringUtil.collapseWhitespace(subject))
    }

    /**
     * @param username The username to set.
     */
    fun setUsername(username: String?) {
        smtp.setUsername(username)
    }

    /**
     * @param password The password to set.
     */
    fun setPassword(password: String?) {
        smtp.setPassword(password)
    }

    /**
     * set the value mimeattach Specifies the path of the file to be attached to the e-mail message. An
     * attached file is MIME-encoded.
     *
     * @param strMimeattach value to set
     * @param type mimetype of the file
     * @param contentID
     * @param disposition
     * @throws PageException
     */
    @Throws(PageException::class)
    fun setMimeattach(strMimeattach: String?, fileName: String?, type: String?, disposition: String?, contentID: String?, removeAfterSend: Boolean) {
        val file: Resource = ResourceUtil.toResourceNotExisting(pageContext, strMimeattach)
        pageContext.getConfig().getSecurityManager().checkFileLocation(file)
        if (!file.exists()) throw ApplicationException("Cannot attach file to mail [$strMimeattach], the file doesn't exist")
        smtp.addAttachment(file, fileName, type, disposition, contentID, removeAfterSend)
    }

    @Throws(PageException::class)
    fun setMimeattach(strMimeattach: String?) {
        setMimeattach(strMimeattach, null, "", null, null, false)
    }

    /**
     * @param spoolenable The spoolenable to set.
     */
    fun setAsync(spoolenable: Boolean) {
        smtp.setSpoolenable(spoolenable)
    }

    // old function for backward compatibility
    fun setSpoolenable(async: Boolean) {
        setAsync(async)
    }

    /**
     * set the value server
     *
     * @param strServer value to set
     * @throws PageException
     */
    @Throws(PageException::class)
    fun setServer(strServer: String?) {
        smtp.setHost(strServer)
    }

    /**
     * set the value mailerid
     *
     * @param mailerid value to set
     */
    fun setMailerid(mailerid: String?) {
        smtp.setXMailer(mailerid)
    }

    /**
     * set the value port The TCP/IP port on which the SMTP server listens for requests. This is
     * normally 25.
     *
     * @param port value to set
     */
    fun setPort(port: Double) {
        smtp.setPort(port.toInt())
    }

    /**
     * @param wraptext The wraptext to set.
     */
    fun setWraptext(wraptext: Double) {
        getPart().setWraptext(wraptext.toInt())
    }

    /**
     * set the value timeout The number of seconds to wait before timing out the connection to the SMTP
     * server.
     *
     * @param timeout value to set
     */
    fun setTimeout(timeout: Double) {
        smtp.setTimeout((timeout * 1000).toInt())
    }

    /**
     * @param charset The charset to set.
     */
    fun setCharset(charset: Charset?) {
        this.charset = CharsetUtil.toCharSet(charset)
    }

    fun setCharset(charsetName: String?) {
        charset = CharsetUtil.toCharSet(charsetName)
    }

    /**
     * set the value group Specifies the query column to use when you group sets of records together to
     * send as an e-mail message. For example, if you send a set of billing statements to customers, you
     * might group on "Customer_ID." The group attribute, which is case sensitive, eliminates adjacent
     * duplicates when the data is sorted by the specified field. See the Usage section for exceptions.
     *
     * @param group value to set
     */
    fun setGroup(group: String?) {
        this.group = group
    }

    /**
     * set the value groupcasesensitive Boolean indicating whether to group with regard to case or not.
     * The default value is YES; case is considered while grouping. If the query attribute specifies a
     * query object that was generated by a case-insensitive SQL query, set the groupCaseSensitive
     * attribute to NO to keep the recordset intact.
     *
     * @param groupcasesensitive value to set
     */
    fun setGroupcasesensitive(groupcasesensitive: Boolean) {
        this.groupcasesensitive = groupcasesensitive
    }

    /**
     * set the value query The name of the cfquery from which to draw data for message(s) to send.
     * Specify this attribute to send more than one mail message, or to send the results of a query
     * within a message.
     *
     * @param query value to set
     */
    fun setQuery(query: String?) {
        this.query = query
    }

    /**
     * set the value maxrows Specifies the maximum number of e-mail messages to send.
     *
     * @param maxrows value to set
     */
    fun setMaxrows(maxrows: Double) {
        this.maxrows = maxrows
    }

    fun setTls(tls: Boolean) {
        smtp.setTLS(tls)
    }

    fun setUsetls(tls: Boolean) {
        smtp.setTLS(tls)
    }

    fun setStarttls(tls: Boolean) {
        smtp.setTLS(tls)
    }

    fun setSsl(ssl: Boolean) {
        smtp.setSSL(ssl)
    }

    fun setUsessl(ssl: Boolean) {
        smtp.setSSL(ssl)
    }

    fun setSecure(ssl: Boolean) {
        smtp.setSSL(ssl)
    }

    fun setDebug(debug: Boolean) {
        smtp.setDebug(debug)
    }

    @Throws(ExpressionException::class)
    fun setPriority(strPriority: String?) {
        var strPriority = strPriority
        strPriority = strPriority.trim().toLowerCase()
        var valid = true
        if (Decision.isNumber(strPriority)) {
            val p: Int = Caster.toIntValue(strPriority, -1)
            if (p < 1 || p > 5) valid = false else priority = p
        } else {
            if ("highest".equals(strPriority)) priority = 1 else if ("urgent".equals(strPriority)) priority = 1 else if ("high".equals(strPriority)) priority = 2 else if ("normal".equals(strPriority)) priority = 3 else if ("low".equals(strPriority)) priority = 4 else if ("lowest".equals(strPriority)) priority = 5 else if ("non-urgent".equals(strPriority)) priority = 5 else if ("none-urgent".equals(strPriority)) priority = 5 else valid = false
        }
        if (!valid) throw ExpressionException("Attribute [priority] of the tag [mail] is invalid [" + strPriority + "], " + "The value should be an integer between [1-5] or "
                + "one of the following [highest, urgent, high, normal, low, lowest, non-urgent]")
    }

    /**
     * set the value startrow Specifies the row in the query to start from.
     *
     * @param startrow value to set
     */
    fun setStartrow(startrow: Double) {
        this.startrow = startrow
    }

    @Throws(ApplicationException::class)
    fun setListener(listener: Object?) {
        this.listener = listener
    }

    /**
     * @param part
     */
    fun addPart(part: MailPart?) {
        val type: String = part.getType()
        if (StringUtil.isEmpty(part.getCharset())) part.setCharset(getCharset())
        if (type != null && (type.equals("text/plain") || type.equals("plain") || type.equals("text"))) {
            part.isHTML(false)
            addClassicBodyPart(part)
        } else if (type != null && (type.equals("text/html") || type.equals("html") || type.equals("htm"))) {
            part.isHTML(true)
            addClassicBodyPart(part)
        } else {
            addBodyPart(part)
        }
    }

    // this was not supported in prior releases
    private fun addBodyPart(part: MailPart?) {
        smtp.setPart(part)
    }

    /**
     * @param part
     */
    private fun addClassicBodyPart(part: MailPart?) {
        if (part.isHTML()) {
            if (!smtp.hasHTMLText()) smtp.setHTMLText(part.getBody(), part.getCharset())
        } else {
            if (!smtp.hasPlainText()) smtp.setPlainText(part.getBody(), part.getCharset())
        }
    }

    @Override
    @Throws(ApplicationException::class)
    fun doStartTag(): Int {
        if (isEmpty(smtp.getTos()) && isEmpty(smtp.getCcs()) && isEmpty(smtp.getBccs())) throw ApplicationException("One of the following attributes must be defined [to, cc, bcc]")
        return EVAL_BODY_BUFFERED
    }

    private fun isEmpty(addrs: Array<InternetAddress?>?): Boolean {
        return addrs == null || addrs.size == 0
    }

    @Override
    fun doInitBody() {
    }

    @Override
    fun doAfterBody(): Int {
        getPart()!!.setBody(bodyContent.getString())
        smtp.setCharset(getCharset())
        getPart()!!.setCharset(getCharset())
        addClassicBodyPart(getPart())
        return SKIP_BODY
    }

    @Override
    @Throws(PageException::class)
    fun doEndTag(): Int {
        if (listener == null) {
            val acs: ApplicationContextSupport = pageContext.getApplicationContext() as ApplicationContextSupport
            listener = acs.getMailListener()
        }
        if (listener != null) smtp.setListener(listener)
        smtp.setTimeZone(pageContext.getTimeZone())
        try {
            smtp.send(pageContext, if (sendTime != null) sendTime.getTime() else 0)
        } catch (e: MailException) {
            throw Caster.toPageException(e)
        }
        return EVAL_PAGE
    }

    /**
     * sets a mail param
     *
     * @param type
     * @param file
     * @param name
     * @param value
     * @param contentID
     * @param disposition
     * @throws PageException
     */
    @Throws(PageException::class)
    fun setParam(type: String?, file: String?, fileName: String?, name: String?, value: String?, disposition: String?, contentID: String?, oRemoveAfterSend: Boolean?) {
        if (file != null) {
            val removeAfterSend = if (oRemoveAfterSend == null) remove else oRemoveAfterSend.booleanValue()
            setMimeattach(file, fileName, type, disposition, contentID, removeAfterSend)
        } else {
            if (name.equalsIgnoreCase("bcc")) setBcc(value) else if (name.equalsIgnoreCase("cc")) setCc(value) else if (name.equalsIgnoreCase("charset")) setCharset(CharsetUtil.toCharset(value, null)) else if (name.equalsIgnoreCase("failto")) setFailto(value) else if (name.equalsIgnoreCase("from")) setFrom(value) else if (name.equalsIgnoreCase("mailerid")) setMailerid(value) else if (name.equalsIgnoreCase("mimeattach")) setMimeattach(value) else if (name.equalsIgnoreCase("priority")) setPriority(value) else if (name.equalsIgnoreCase("replyto")) setReplyto(value) else if (name.equalsIgnoreCase("subject")) setSubject(value) else if (name.equalsIgnoreCase("to")) setTo(value) else smtp.addHeader(name, value)
        }
    }

    private fun getPart(): tachyon.runtime.net.mail.MailPart? {
        if (part == null) part = MailPart(pageContext.getConfig().getMailDefaultCharset())
        return part
    }

    /**
     * @return the charset
     */
    fun getCharset(): Charset? {
        if (charset == null) charset = CharsetUtil.toCharSet(pageContext.getConfig().getMailDefaultCharset())
        return CharsetUtil.toCharset(charset)
    }

    fun setSendtime(dt: DateTime?) {
        sendTime = dt
    }
}