/**
 * Copyright (c) 2014, the Railo Company Ltd.
 * Copyright (c) 2015, Tachyon Assosication Switzerland
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see <http:></http:>//www.gnu.org/licenses/>.
 *
 */
package tachyon.runtime.db.driver

import java.sql.Array

class ConnectionProxy(factory: Factory, conn: Connection) : Connection {
    private val conn: Connection
    private val factory: Factory
    val connection: Connection
        get() = conn

    @Override
    @Throws(SQLException::class)
    fun createStatement(): Statement {
        return factory.createStatementProxy(this, conn.createStatement())
    }

    @Override
    @Throws(SQLException::class)
    fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement {
        return factory.createStatementProxy(this, conn.createStatement(resultSetType, resultSetConcurrency))
    }

    @Override
    @Throws(SQLException::class)
    fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement {
        return factory.createStatementProxy(this, conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability))
    }

    @Override
    @Throws(SQLException::class)
    fun prepareCall(sql: String?): CallableStatement {
        return factory.createCallableStatementProxy(this, conn.prepareCall(sql), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int): CallableStatement {
        return factory.createCallableStatementProxy(this, conn.prepareCall(sql, resultSetType, resultSetConcurrency), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement {
        return factory.createCallableStatementProxy(this, conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?): PreparedStatement {
        return factory.createPreparedStatementProxy(this, conn.prepareStatement(sql), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement {
        return factory.createPreparedStatementProxy(this, conn.prepareStatement(sql, autoGeneratedKeys), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, columnIndexes: IntArray?): PreparedStatement {
        return factory.createPreparedStatementProxy(this, conn.prepareStatement(sql, columnIndexes), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, columnNames: Array<String?>?): PreparedStatement {
        return factory.createPreparedStatementProxy(this, conn.prepareStatement(sql, columnNames), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        return factory.createPreparedStatementProxy(this, conn.prepareStatement(sql, resultSetType, resultSetConcurrency), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement {
        return factory.createPreparedStatementProxy(this, conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql)
    }

    @Override
    @Throws(SQLException::class)
    fun isWrapperFor(iface: Class<*>?): Boolean {
        return conn.isWrapperFor(iface)
    }

    @Override
    @Throws(SQLException::class)
    fun <T> unwrap(iface: Class<T>?): T {
        return conn.unwrap(iface)
    }

    @Override
    @Throws(SQLException::class)
    fun clearWarnings() {
        conn.clearWarnings()
    }

    @Override
    @Throws(SQLException::class)
    fun close() {
        conn.close()
    }

    @Override
    @Throws(SQLException::class)
    fun commit() {
        conn.commit()
    }

    @Override
    @Throws(SQLException::class)
    fun createArrayOf(typeName: String?, elements: Array<Object?>?): Array {
        return conn.createArrayOf(typeName, elements)
    }

    @Override
    @Throws(SQLException::class)
    fun createBlob(): Blob {
        return conn.createBlob()
    }

    @Override
    @Throws(SQLException::class)
    fun createClob(): Clob {
        return conn.createClob()
    }

    @Override
    @Throws(SQLException::class)
    fun createNClob(): NClob {
        return conn.createNClob()
    }

    @Override
    @Throws(SQLException::class)
    fun createSQLXML(): SQLXML {
        return conn.createSQLXML()
    }

    @Override
    @Throws(SQLException::class)
    fun createStruct(typeName: String?, attributes: Array<Object?>?): Struct {
        return conn.createStruct(typeName, attributes)
    }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var autoCommit: Boolean
        get() = conn.getAutoCommit()
        set(autoCommit) {
            conn.setAutoCommit(autoCommit)
        }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var catalog: String?
        get() = conn.getCatalog()
        set(catalog) {
            conn.setCatalog(catalog)
        }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLClientInfoException::class)
    @set:Override
    var clientInfo: Properties
        get() = conn.getClientInfo()
        set(properties) {
            conn.setClientInfo(properties)
        }

    @Override
    @Throws(SQLException::class)
    fun getClientInfo(name: String?): String {
        return conn.getClientInfo(name)
    }

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var holdability: Int
        get() = conn.getHoldability()
        set(holdability) {
            conn.setHoldability(holdability)
        }

    @get:Throws(SQLException::class)
    @get:Override
    val metaData: DatabaseMetaData
        get() = conn.getMetaData()

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var transactionIsolation: Int
        get() = conn.getTransactionIsolation()
        set(level) {
            conn.setTransactionIsolation(level)
        }

    @get:Throws(SQLException::class)
    @get:Override
    val typeMap: Map<String, Any>
        get() = conn.getTypeMap()

    @get:Throws(SQLException::class)
    @get:Override
    val warnings: SQLWarning
        get() = conn.getWarnings()

    @get:Throws(SQLException::class)
    @get:Override
    val isClosed: Boolean
        get() = conn.isClosed()

    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var isReadOnly: Boolean
        get() = conn.isReadOnly()
        set(readOnly) {
            conn.setReadOnly(readOnly)
        }

    @Override
    @Throws(SQLException::class)
    fun isValid(timeout: Int): Boolean {
        return conn.isValid(timeout)
    }

    @Override
    @Throws(SQLException::class)
    fun nativeSQL(sql: String?): String {
        return conn.nativeSQL(sql)
    }

    @Override
    @Throws(SQLException::class)
    fun releaseSavepoint(savepoint: Savepoint?) {
        conn.releaseSavepoint(savepoint)
    }

    @Override
    @Throws(SQLException::class)
    fun rollback() {
        conn.rollback()
    }

    @Override
    @Throws(SQLException::class)
    fun rollback(savepoint: Savepoint?) {
        conn.rollback(savepoint)
    }

    @Override
    @Throws(SQLClientInfoException::class)
    fun setClientInfo(name: String?, value: String?) {
        conn.setClientInfo(name, value)
    }

    @Override
    @Throws(SQLException::class)
    fun setSavepoint(): Savepoint {
        return conn.setSavepoint()
    }

    @Override
    @Throws(SQLException::class)
    fun setSavepoint(name: String?): Savepoint {
        return conn.setSavepoint(name)
    }

    @Override
    @Throws(SQLException::class)
    fun setTypeMap(map: Map<String?, Class<*>?>?) {
        conn.setTypeMap(map)
    }

    /*
		 * / used reflection to make sure this work with Java 5 and 6 try { return
		 * Caster.toString(conn.getClass().getMethod("getSchema", new Class[]{}).invoke(conn, new
		 * Object[]{})); } catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 *//*
		 * / used reflection to make sure this work with Java 5 and 6 try {
		 * conn.getClass().getMethod("setSchema", new Class[]{String.class}).invoke(conn, new
		 * Object[]{schema}); } catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 */
    @get:Throws(SQLException::class)
    @get:Override
    @set:Throws(SQLException::class)
    @set:Override
    var schema: String?
        get() = conn.getSchema()
        /*
		 * / used reflection to make sure this work with Java 5 and 6 try { return
		 * Caster.toString(conn.getClass().getMethod("getSchema", new Class[]{}).invoke(conn, new
		 * Object[]{})); } catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 */
        set(schema) {
            conn.setSchema(schema)
            /*
		 * / used reflection to make sure this work with Java 5 and 6 try {
		 * conn.getClass().getMethod("setSchema", new Class[]{String.class}).invoke(conn, new
		 * Object[]{schema}); } catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 */
        }

    // used only with java 7, do not set @Override
    @Throws(SQLException::class)
    fun abort(executor: Executor?) {
        conn.abort(executor)
        /*
		 * // used reflection to make sure this work with Java 5 and 6 try {
		 * conn.getClass().getMethod("abort", new Class[]{Executor.class}).invoke(conn, new
		 * Object[]{executor}); } catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 */
    }

    @Override
    @Throws(SQLException::class)
    fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        conn.setNetworkTimeout(executor, milliseconds)
        /*
		 * / used reflection to make sure this work with Java 5 and 6 try {
		 * conn.getClass().getMethod("setNetworkTimeout", new
		 * Class[]{Executor.class,int.class}).invoke(conn, new Object[]{executor,milliseconds}); }
		 * catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 */
    }

    /*
		 * / used reflection to make sure this work with Java 5 and 6 try { return
		 * Caster.toIntValue(conn.getClass().getMethod("getNetworkTimeout", new Class[]{}).invoke(conn, new
		 * Object[]{})); } catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 */
    @get:Throws(SQLException::class)
    @get:Override
    val networkTimeout: Int
        get() = conn.getNetworkTimeout()

    /*
		 * / used reflection to make sure this work with Java 5 and 6 try { return
		 * Caster.toIntValue(conn.getClass().getMethod("getNetworkTimeout", new Class[]{}).invoke(conn, new
		 * Object[]{})); } catch(Throwable t) {ExceptionUtil.rethrowIfNecessary(t); if(t instanceof
		 * InvocationTargetException && ((InvocationTargetException)t).getTargetException() instanceof
		 * SQLException) throw (SQLException)((InvocationTargetException)t).getTargetException(); throw new
		 * PageRuntimeException(Caster.toPageException(t)); }
		 */
    init {
        this.conn = conn
        this.factory = factory
    }
}